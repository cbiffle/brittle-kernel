Memory Region Protocol
======================

A memory object is a naturally aligned power-of-two-sized section of address
space.

A key to a memory object additionally carries attributes and implements the
Memory Region Protocol, 

Keys to memory regions of 256 bytes and larger can have each eighth of their
address space individually disabled.  Bytes disabled in this way remain members
of the parent memory region object.


Inspect Region (0)
------------------

Returns the actual ARMv7-M MPU values that would be loaded if this region were
assigned to a Context's MPU Region Registers.  This encoding is awkward but
honest.

Arguments:
- d0: descriptor

Results:
- d0: success descriptor
- d1: Region Base Address Register contents
- d2: Region Attribute and Size Register contents


Change Attributes (1)
---------------------

Derives a new key with different attributes, given by a replacement value for
the Region Attribute and Size Register (RASR).

For this operation to succeed, the new value must imply equal or weaker access
than the old one, and must not enable any subregions that were previously
disabled.

The size and enable fields, and any bits reserved in the ARMv7-M spec, are
ignored.

Arguments:
- d0: descriptor
- d1: new RASR value.

Results:
- d0: success descriptor
- k1: new key

Exceptions:
- `k.bad_argument` if the RASR value would increase access.


Split Region (2)
----------------

Breaks a region into two: the bottom and top halves.  The two halves are the
same size, and are thus still correctly aligned.

Splitting is impossible in the following circumstances:

 1. The memory region is already the architecture's minimum size (32 bytes).

 2. The invoked key has any subregion disable bits set.

Splitting a memory region creates one net new object, and so the operation
requires donation of a Slot key; the other object uses the slot originally used
by the target.  Both the Slot key and the target are consumed.

The two keys returned in the reply represent the only extant keys to each half.

Both returned keys have the same memory attributes (access permissions,
cacheability, etc.) as the original.

TODO: splitting should be controlled by a bit in the brand.

Arguments:
- d0: descriptor
- k1: slot key being donated.

Results:
- d0: success descriptor
- k1: bottom half
- k2: top half

Exceptions:
- `k.bad_operation` if the region cannot be split for size reasons, or because
  the subregion disable bits are set.
- `k.bad_kind` if the provided key is not a Slot key.


Become Object (3)
-----------------

Destroys this memory object, using the memory it occupied to create a new
object together with a donated slot key (also destroyed).

This object must be exactly the right size for the requested type of object; see
below for sizes.

Sizes are defined in terms of the configuration-time constant P: number of
priority levels.

Returns the sole extant key to the new object.  The new key's brand is the
type-specific "default brand" for the object type in question.

TODO: this should be a permission bit.

Arguments:
- d0: descriptor
- d1: desired object type (size)
  - 0: context (512)
  - 1: gate (16P)
  - 2: reply gate (8 + 8P)
  - 3: interrupt (32 + 8P)
  - 4: systick (32 + 8P)

Results:
- d0: success descriptor
- k1: key to new object.

Exceptions:
- `k.bad_argument` if the object type code is unrecognized.
- `k.bad_operation` if the memory key being used has subregion disable bits set,
  or this object is the wrong size for the requested type.


Peek (4)
--------

Reads a word of data from this object's memory.  For the purposes of this
operation, this memory region is addressed as an array of words, with indices
starting at zero.

Arguments:
- d0: descriptor
- d1: offset

Results:
- d0: success descriptor
- d1: word of data

Exceptions:
- `k.bad_argument` if the offset is out of range.


Poke (5)
--------

Writes a word of data into this object's memory.  For the purposes of this
operation, this memory region is addressed as an array of words, with indices
starting at zero.

Arguments:
- d0: descriptor
- d1: offset
- d2: word of data

Results:
- d0: success descriptor

Exceptions:
- `k.bad_argument` if the offset is out of range.
