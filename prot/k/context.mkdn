Context Protocol
================

This is the native protocol spoken by contexts, the kernel objects that
implement tasks at the application and system level.  It allows control of the
context and modification of its content.  Context keys should generally be
closely held by the system, as the operations in this protocol can violate
system invariants (although not kernel ones).


Read Register (0)
-----------------

Reads a register, by index, from the context.  Only registers stored in the
Context can be read in this way.  Currently available registers are:

- 4 - 11: general-purpose registers r4 - r11.
- 13: stack pointer.
- 17: BASEPRI.

Arguments:
- d0: descriptor
- d1: register index.

Results:
- d0: success descriptor.
- d1: register contents.

Exceptions:
- `k.bad_argument` if the register number is invalid for use with this call.


Write Register (1)
------------------

Writes a register, by index, in the context.  Only registers stored in the
Context can be read in this way.  Currently available registers are:

- 4 - 11: general-purpose registers r4 - r11.
- 13: stack pointer.
- 17: BASEPRI.

Arguments:
- d0: descriptor
- d1: register index
- d2: value

Results:
- d0: success descriptor.

Exceptions:
- `k.bad_argument` if the register number is invalid for use with this call.


Read Key (2)
------------

Reads a key from the context's keyring by index.

Arguments:
- d0: descriptor.
- d1: key index.

Results:
- d0: success descriptor.
- k1: key from context.

Exceptions:
- `k.bad_argument` if the key index is out of range.


Write Key (3)
-------------

Writes a key into the context's keyring.

Arguments:
- d0: descriptor
- d1: key index
- k1: key

Results:
- d0: success descriptor.

Exceptions:
- `k.bad_argument` if the key index is out of range.


Read MPU Region (4)
-------------------

Reads out the contents of one of the MPU regions.

Arguments:
- d0: descriptor
- d1: region index

Results:
- d0: success descriptor
- k1: region key

Exceptions:
- `k.bad_argument` if the region index is out of range.


Write MPU Region (5)
--------------------

Alters one of the MPU regions.

The change takes effect when the context is next activated, unless it is
already the active context, in which case it takes effect immediately, before
return from the send.

Primitive memory range keys can be loaded directly into the region registers.
Any other type of key will be treated as a null key and confer no authority.

Arguments:
- d0: descriptor
- d1: region index
- k1: region key

Results:
- d0: success descriptor

Exceptions:
- `k.bad_argument` if the region index is out of range.


Set Runnable (6)
----------------

Switches the Context into "runnable" state.  If the Context was already
runnable (including running) then this has no effect.

If the Context is blocked in an IPC, it will be aborted with an exception.

Arguments:
- d0: descriptor

Results:
- d0: success descriptor


Read Priority (7)
-----------------

Gets the current priority of the context.

Arguments:
- d0: descriptor

Results:
- d0: success descriptor
- d1: priority

Bugs:
- Priorities ought to be capabilities.


Write Priority (8)
------------------

Alters the current priority of the context.

Arguments:
- d0: descriptor
- d1: priority

Results:
- d0: success descriptor

Bugs:
- Priorities ought to be capabilities.


Save Kernel Registers (9)
--------------------------

Saves the kernel-maintained registers into memory at consecutive addresses.  The
caller (not the target Context) must have rights to write those addresses.

This operation is intended to make "swapping" -- multiplexing multiple logical
tasks across a single Context -- faster.

The kernel-maintained registers are r4 - r11 and basepri.  When saved to memory
they are written in that order (by ascending address).

Arguments:
- d0: descriptor
- d1: dest address.

Results:
- d0: success descriptor.

Exceptions:
- `k.fault` if any of the nine words starting at the destination address cannot
  be written by the caller.

Bugs:
- What if the caller is an Interrupt?  Interrupts don't have memory rights.


Restore Kernel Registers (10)
-----------------------------

Restores the kernel-maintained registers in this Context from consecutive memory
locations.  The caller (not the target Context) must have rights to read from
the memory locations.

This operation is intended to make "swapping" -- multiplexing multiple logical
tasks across a single Context -- faster.

The kernel-maintained registers are r4 - r11 and basepri.  When restored from
memory they are read in that order (by ascending address).

Arguments:
- d0: descriptor
- d1: source address.

Results:
- d0: success descriptor.

Exceptions:
- `k.fault` if any of the nine words starting at the source address cannot be
  read by the caller.

Bugs:
- What if the caller is an Interrupt?  Interrupts don't have memory rights.
- If a fault happens when the registers are only partially restored, the Context
  may be left in an intermediate state.


