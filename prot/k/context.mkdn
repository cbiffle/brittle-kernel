Context Protocol
================

This is the native protocol spoken by contexts, the kernel objects that
implement tasks at the application and system level.  It allows control of the
context and modification of its content.  Context keys should generally be
closely held by the system, as the operations in this protocol can violate
system invariants (although not kernel ones).


Read Register (0)
-----------------

Reads a register, by index, from the context.

Register indices are inherently platform-specific; see the example list for
ARMv7-M below.

Arguments:
- d0: descriptor
- d1: register index.

Results:
- d0: success descriptor.
- d1: register contents.

Exceptions:
- `k.index_out_of_range`


### Example register list for ARMv7-M

- 0 - 15: general-purpose registers r0 - r15.
- 16: program status register.
- 17: BASEPRI.

Note that the implemented range for BASEPRI is system-specific, but the value
accessed through this interface is always 8 bits.  Applications should adjust as
needed.


Write Register (1)
------------------

Writes a register, by index, in the context.

Register indices are shared with Read Register, above.

Arguments:
- d0: descriptor
- d1: register index
- d2: value

Results:
- d0: success descriptor.

Exceptions:
- `k.index_out_of_range`


Read Key (2)
------------

Reads a key from the context's keyring by index.

Arguments:
- d0: descriptor.
- d1: key index.

Results:
- d0: success descriptor.
- k1: key from context.

Exceptions:
- `k.index_out_of_range`


Write Key (3)
-------------

Writes a key into the context's keyring.

Arguments:
- d0: descriptor
- d1: key index
- k1: key

Results:
- d0: success descriptor.

Exceptions:
- `k.index_out_of_range`


Read MPU Region (4)
-------------------

Reads out the contents of one of the MPU regions.

Arguments:
- d0: descriptor
- d1: region index

Results:
- d0: success descriptor
- k1: region key

Exceptions:
- `k.index_out_of_range`


Write MPU Region (5)
--------------------

Alters one of the MPU regions.

The change takes effect when the context is next activated, unless it is
already the active context, in which case it takes effect immediately, before
return from the send.

Primitive memory range keys can be loaded directly into the region registers.
Any other type of key will be treated as a null key and confer no authority.

Arguments:
- d0: descriptor
- d1: region index
- k1: region key

Results:
- d0: success descriptor

Exceptions:
- `k.index_out_of_range`


Set Runnable (6)
----------------

Switches the Context into "runnable" state.  If the Context was already
runnable (including running) then this has no effect.

If the Context is blocked in an IPC, it will be aborted with an exception.

Arguments:
- d0: descriptor

Results:
- d0: success descriptor


Read Priority (7)
-----------------

Gets the current priority of the context.

Arguments:
- d0: descriptor

Results:
- d0: success descriptor
- d1: priority

Bugs:
- Priorities ought to be capabilities.


Write Priority (8)
------------------

Alters the current priority of the context.

Arguments:
- d0: descriptor
- d1: priority

Results:
- d0: success descriptor

Bugs:
- Priorities ought to be capabilities.


Save Kernel Registers (9)
--------------------------

Saves the kernel-maintained registers into memory at consecutive addresses.  The
caller (not the target Context) must have rights to write those addresses.

This operation is intended to make "swapping" -- multiplexing multiple logical
tasks across a single Context -- faster.

The kernel-maintained registers are r4 - r11 and basepri.  When saved to memory
they are written in that order (by ascending address).

Arguments:
- d0: descriptor
- d1: dest address.

Results:
- d0: success descriptor.

Exceptions:
- `k.fault` if any of the nine words starting at the destination address cannot
  be written by the caller.

Bugs:
- What if the caller is an Interrupt?  Interrupts don't have memory rights.


Restore Kernel Registers (10)
-----------------------------

Restores the kernel-maintained registers in this Context from consecutive memory
locations.  The caller (not the target Context) must have rights to read from
the memory locations.

This operation is intended to make "swapping" -- multiplexing multiple logical
tasks across a single Context -- faster.

The kernel-maintained registers are r4 - r11 and basepri.  When restored from
memory they are read in that order (by ascending address).

Arguments:
- d0: descriptor
- d1: source address.

Results:
- d0: success descriptor.

Exceptions:
- `k.fault` if any of the nine words starting at the source address cannot be
  read by the caller.

Bugs:
- What if the caller is an Interrupt?  Interrupts don't have memory rights.
- If a fault happens when the registers are only partially restored, the Context
  may be left in an intermediate state.


